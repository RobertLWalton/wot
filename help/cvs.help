CVS HELP

File:		cvs.help
Author:		Bob Walton (walton@deas.harvard.edu)
Version:	1

Purpose: CVS implements a system for storing past and
present versions of a file "foo" in another file
"foo,v" that is located in a CVS repository.  In storing
many versions of "foo" in "foo,v", CVS stores mostly
just the differences between versions, thus saving much
storage space compared to a normal file system.  The CVS
repository can be accessed from any account that can
read and write the files and directories of the
repository, or from any remote system that can log into
such an account using rlogin or ssh.  CVS is standardly
installed in modern UNIX systems, and it is possible to
install CVS under the various window's operating
systems.

CVS is useful for cooperative projects where many people
work on the same set of files.  It permits more than one
person to work on the same file in parallel, and merges
the results, though some human intervention is required
for checking and cleanup of the merge.

CVS uses RCS to maintain the ",v" files.  Like RCS, CVS
is also useful for backing up files in case you acci-
dentally delete them, and for seeing what changes you
recently made.  If the repository is remote from you,
accessing it using CVS can be slower, however, than a
local RCS system.  It is easy to move ",v" RCS files
into a CVS repository and to move them out again, so it
is easy to switch between using CVS and using RCS.

The CVS repository is a directory with subdirectories.
The repository contains subdirectories containing
",v" files or other subdirectories.  Users maintain
copies of parts of the repository with ",v" files
replaced by the files they log (i.e., "foo,v"
replaced by "foo").  Users may check files in and
out, and may check all the files and subdirectories
in a subdirectory system in or out.  Checking "foo"
in means storing the current version of "foo" in
"foo,v"; checking "foo" out means copying the most
recent version of "foo" stored in "foo,v" to the
user's version of "foo".  The command in CVS to
check files in is called `commit', and the command
to check files out is called `update'.

The subdirectory organization of the repository is the
same as the subdirectory organization of the user of
the repository: the differences are that where there
is a file named "foo,v" in the repository, there is
a file named "foo" in the associated user subdirectory,
and that the user subdirectory has a CVS subdirectory
used for bookkeeping.  The root of the repository has
a CVSROOT subdirectory for bookkeeping, and the
repository subdirectories may have Attic subdirectories
in which ",v" files that have been `removed' from the
repository are kept (so nothing is ever lost).

The top level of the repository is not itself matched
to any user subdirectory.  Rather, the top level
subdirectories are said to define `modules' and are
matched to user subdirectories.  Modules are checked
out by a separate CVS `checkout' command, not all
modules in a repository need be checked out by a given
user.

The repository name is the full pathname of the
repository directory if the repository is on the local
computer; or is of the form:

	login-name@host-name:full-directory-pathname

if the repository is on a local computer.  Because :
is legal in a windows operating system file name, on
the windows operating system a local pathname is of
the form:

	local:full-directory-pathname


Environment Settings
----------- --------

You should put

	setenv CVSREAD

in your .cshrc file.  This causes files checked out from
the repository to be marked read-only.  To change a file
you must first

	chmod u+w filename

and then edit or change the file.  If you do not proceed
in this fashion, you will find it easy to accidentally
change a file and check it in, because the commit
command typically checks in ALL the changed files in a
directory tree.

If you have the secure shell ssh available to access the
account named in a remote repository, then you should
put:

	setenv CVS_RSH ssh

in your .cshrc file.  If you do NOT do this, rsh will be
used to access the remote repository.

If you are doing a group project in which all users are
in a UNIX group, it is important that your umask be set
to 7, and not 77, when cvs is accessing the repository.
To accomplish this put:

	setenv CVSUMASK 007

in the .cshrc file of the account that locally accesses
the repository.  If you do NOT do this, but instead let
cvs access the repository with umask equal to 77, the
repository files created when you run cvs will be
inaccessible to your group mates.

Note that using the above setenv implies that ALL CVS
repositories you manage with a particular account will
have group write permissions.  If some of these
repositories are not to be group accessible, you may
protect the repository top level directory against group
access, and, if you like, periodically remove group
permissions from the files and subdirectories in the
repository.

Standard CVS User Commands:
-------- --- ---- --------

Note: Commands without a filename run on all files
in the current directory and its subdirectories.
The same command with filenames runs only on the named
files in the current directory.

cvs -d repository checkout module-name

	Does a `mkdir module-name' and checks out all
	files and subdirectories of the named module
	(i.e., top level subdirectory).

cvs status -v
cvs status -v | grep Status
cvs status -v filename ...
cvs status -v filename ... | grep Status

	Identifies all files in the repository that
	store the history of files in the current
	directory and its subdirectories, and for
	each such file gives the status of the user's
	version of the file.  A file Status is most
	commonly one of:

	    Up-to-date	User's version of file is the
			same as repository's version.

	    Locally	User has modified his version of
	    Modified    the file since he checked it
			out of the repository.

	    Needs	Repository version is more
	    Patch	recent than the user's version.
	    or Checkout

	    Needs	User has modified his version of
	    Merge	the files since he checked it
			out of the repository, and the
			repository now holds a version
			more recent than the version the
			user checked out.

	Unfortunately, files other users have added and
	the current user has never checked out are not
	mentioned.  You need to do a cvs update -d -P
	to get them or even to see them.


cvs diff
cvs diff filename ...
cvs diff -rVVV filename
	Prints a diff listing between the last version
	of a file that the user checked out of the
	repository (NOTE: this may not be the latest
	version in the repository) and the user's
	version of the file, if the user has modified
	the file.  With -rVVV, release VVV (e.g., 1.4)
	of the file in the repository is used for making
	the diff listing.


cvs update -d -P
cvs update filename ..
	Checks out files that have been updated in the
	repository since the user last checked out the
	files.  The command without filenames and
	with the -d and -P options also removes files
	removed from the repository, adds files added
	to the repository, and removes local copies of
	directories that are empty in the repository.

cvs commit -m update
cvs commit -m update filename
	Checks in files that the user has updated since
	the user last checked out the files.  Also
	removes files or directories removed from the
	repository that were identified by the CVS
	`remove' command below, and adds files or
	directories to the repository that were
	identified by the CVS `add' command below.
	The `-m update' parameter just satisfies
	the need of `cvs commit' for a message from
	its user telling the purpose of the commit.

cvs add filename ...
cvs add directory ...
cvs remove filename ...
	Marks files that are to be added or removed from
	the repository.  The actual addition or removal
	is done by the next CVS `commit' command.

	A directory can also be added to the repository.
	However, a directory cannot be removed.  Note
	that empty directories may be removed by the
	`cvs update ... -P' command described below,
	so you should be sure any useful directory is
	not empty (in worst case by adding a .cvskeep
	file with meaningless contents).

	A directory cannot be removed from the
	repository in this way, or even easily.  See
	`moving and removing directories' below.

	To add just make the file or directory and
	mention it in an `add' command.

	To remove the file or directory, first delete it
	and then mention it in a cvs `remove' command.

	Removed stuff is not actually removed from the
	repository.  It is moved to an Attic
	subdirectory of the directory it was in.  The
	",v" files in an Attic have state `dead' for
	their last revision, and this prevents the
	use of these files by CVS even if they are
	moved out of the Attic subdirectorys.  The
	rcs command `rcs -sExp filename,v' will
	change the state to the normal `Exp' state
	and permit these ",v" files to be reused.

Mv'ing and cp'ing ",v" files in the repository:
	If you want to duplicate or rename files it
	is not possible to do this properly with CVS
	commands.  Instead be sure all users have the
	relevant files committed and updated, go the
	repository itself, and `cp -p' or `mv' the
	",v" files or directories.  You can also make
	new subdirectories in the repository.

	Then run the `update' command for all users.
	This will get files with new names out of the
	repository and delete files with obsolete names.

Mv'ing and rmdir'ing directories in the repository:
	If you do this you are going to get into
	trouble.

	The safe thing to do is to mv or rm all files
	in the directories and not touch the directories
	themselves.  Then wait a long time until users
	who are doing `cvs update ... -P' have deleted
	all user copies of the directories.  Only then,
	AFTER ALL USER COPIES have been removed, is it
	safe to rmdir the repository directories.

	If you are a user who still has a copy of a
	directory that has been rmdir'ed from the
	repository, cvs will not work.  What you must
	do are TWO things.  First, `rm -rf' your local
	copy of the directory: specifically, you must
	get rid of all CVS subdirectories in the
	directory or its subdirectories.  Second,
	remove mention of the subdirectory from its
	parent directory's CVS/Entries file.  If you do
	only one of these things and then run a cvs
	command, cvs will undo the one thing you did and
	then suffer an error.

Mv'ing or cp'ing ",v" files between RCS and CSV.
	You can `mv' or `cp -p' files from RCS to a
	CVS repository or vice versa.  When moving
	an RCS file into the repository, be sure it is
	unlocked (use `rcs -u filename,v' to unlock
	the file).

ignoring files.
	Several cvs commands print the names of files
	that are not in the repository, such as .dvi
	or .o files.  There are two ways to get cvs
	to ignore such files.  First, make a cvsignore
	file in the CVSROOT module of the repository
	that includes a filename pattern matching the
	names of the files to be ignored.  E.g.,
	cvsignore might have the line `*.dvi *.o'.
	Alternatively, a .cvsignore file in a
	a subdirectory will cause cvs to ignore all
	the files in that subdirectory whose names
	match the patterns in the .cvsignore file.




Infrequently used commands:
------------------------

cvs -d repository-full-pathname init
	This is used to create a repository.

cd repository-full-pathname; mkdir module; \
    chmod 770 module
	Make a new module.

cvs log
cvs log filename ...
	Print the status of all revisions of files.

cvs tag symbolic_tag
cvs tag symbolic_tag filename ...
	Attach a symbolic_tag (any character string,
	quoted if it contains a space) to the
	current versions of files.  This can be
	used to mark all the file versions that make
	a system version.

cvs -d repository-name checkout -r symbolic_tag
	TEST THIS

TO BE DONE:

CVS/Entries CVS/Root CVS/Repository

Merging

Changing repository location.
