#!/bin/sh

# Backup directories.
#
# File:		backup
# Author:	Bob Walton <walton@deas.harvard.edu>
# Date:		Sat Aug 26 06:49:36 EDT 2006
#
# The authors have placed this program in the public
# domain; they make no warranty and accept no liability
# for this program.
#
# RCS Info (may not be true date or author):
#
#   $Author: walton $
#   $Date: 2006/08/26 11:09:36 $
#   $RCSfile: backup3,v $
#   $Revision: 1.16 $

case "$1" in
-doc* )
	echo "
backup [-tgz] [-move] [-raw] [-burn] [-check] [-clean]\
NAME ...

    Backs up the NAME'd items which are defined in
    the file BACKUP.rc of the current directory.
    This file contains lines of the form:

    	NAME_directories="DIRECTORY ..."

    to define each name.  The file must also contain
    a line of the form

    	host=THISHOST

    to define THISHOST.

    For each DIRECTORY creates the file THISHOST-
    DIRECTORY-DATE.tgz in the current directory.  In
    the name of this file, \`/'s are deleted from the
    beginning and end of DIRECTORY and changed to \`-'s
    elsewhere in DIRECTORY.  Deletes any old version of
    this file.  Excludes files listed in DIRECTORY/
    .backup-ignore from the .tgz (.backup-ignore is
    passed as the --exclude-from argument to tar).

    Then proceeds according to the settings of the
    BACKUP.rc.
    
    If BACKUP.rc file contains

    	NAME_remote_directory=REMOTE_DIRECTORY

    this program executes for each DIRECTORY:

    	efm moveto REMOTE_DIRECTORY \\
	    THISHOST-DIRECTORY-DATE.tgz

    The REMOTE_DIRECTORY name must be acceptable to scp.

    If this program uses efm, this program at its end
    executes

	mv -f EMF-INDEX.listall EMF-INDEX.listall-
	efm listall > EMF-INDEX.listall
    	efm list THISHOST-DIRECTORY-DATE.tgz ...

    which saves all the non-key EFM-INDEX information
    in EFM-INDEX.listall and lists all the non-key
    EFM-INDEX information for the files just moved by
    this program.

    If for a given NAME, BACKUP.rc contains

    	name_make_cd=1

    this program creates the file:

    	THISHOST-NAME-DATE.raw

    containing the raw CD image.  It then executes

    	cdrecord -v CD-OPTIONS THISHOST-NAME-DATE.raw
	eject /dev/cdrom

    where CD-OPTIONS if it exists is defined by the
    BACKUP.rc line

    	cd_options="CD-OPTIONS"

    In particular, the line

    	cd_options="-raw"

    should be used if your CD driver has bad firmware
    so that the check below often does not work.

    Then this program checks the CD by executing

	cmp /dev/cdrom THISHOST-NAME-DATE.raw
    	eject /dev/cdrom

    Lastly this program cleans up by executing

    	rm THISHOST-DIRECTORY-DATE.tgz ... \\
	   THISHOST-NAME-DATE.raw

    If several CD's are made, this program pauses be-
    tween CD's to permit manual change of CDs.

    The -tgz option suppresses the making of .tgz files,
    which must already exist.  -move suppresses using
    \`efm moveto' for the .tgz file.  -raw suppresses
    making .raw files, -burn suppresses burning CD's,
    -check suppresses checking CD's, and -clean suppres-
    ses .tgz and .raw file removal for CD's, and changes
    \`efm moveto' to \`efm copyto' so .tgz files are not
    deleted by efm.

    If the BACKUP.rc file contains

    	efm_trace=on
    or
    	efm_trace=off

    this program sets the efm trace accordingly while
    this program is running, and then resets the efm
    trace to its former value.
"
    exit 1
    ;;
esac

source BACKUP.rc

tgz=1
move=1
raw=1
burn=1
check=1
clean=1
while test x = x
do
    case "$1" in
    -tgz )	tgz=0;;
    -move )	move=0;;
    -raw )	raw=0;;
    -burn )	burn=0;;
    -check )	check=0;;
    -clean )	clean=0;;
    * ) break;;
    esac
    shift
done

d=`date +%Y-%m-%d`
efms=""
efm_used=0
efm_old_trace=""
while test "$1" != ""
do
    name="$1"
    shift
    next_name="$1"
    directories=${name}_directories
    remote=${name}_remote_directory
    make_cd=${name}_make_cd
    cd=${host}-${name}-$d
    r=${cd}.raw

    # Make .tgz files.

    tgzs=""
    for dir in ${!directories}
    do
	if test ! -d $dir
	then
	    echo "ERROR: $dir is not a directory"
	    continue
	fi

	n="$dir"
	while test x = x
	do
	    case "$n" in
	    /*) n=` expr "$n" : '/\(.*\)$' `;;
	    */) n=` expr "$n" : '\(.*\)/$' `;;
	    *) break;;
	    esac
	done
	n=`echo "$n" | tr / -`

	t=${host}-$n-$d.tgz

	if test $tgz -eq 1
	then

	    # Clean up efm index if necessary.
	    # We must do this before remaking existing
	    # .tgz files or efm will not work.

	    if test "${!remote}" != ""
	    then

		# Be sure efm starts properly before
		# calling efm listed.

		efm start
		if test $? -ne 0
		then
		    echo "ERROR starting efm"
		    exit 1
		fi

		if test "`efm listfiles $t`" == $t
		then
		    if test $efm_used -eq 0
		    then
		      efm_used=1
		      if test "$efm_trace" != ""
		      then
		        set efm_old_trace="`efm trace`"
		        efm trace $efm_trace
		      fi
		    fi
		    echo efm remove "${!remote}" $t
		    efm remove "${!remote}" $t
		    if test $? -ne 0
		    then
			echo "ERROR executing" \
			     "efm remove"
			exit 1
		    fi
		    echo ""
		fi
	    fi

	    # Make .tgz file.

	    opt=""
	    if test -r $dir/.backup-ignore
	    then
		opt="--exclude-from $dir/.backup-ignore"
	    fi
	    rm -f $t
	    echo tar zcf $t $opt $dir
	    tar zcf $t $opt $dir
	    if test $? -ne 0
	    then
	        echo "ERROR executing tar"
		exit 1
	    fi
	    chmod 400 $t
	    if test $? -ne 0
	    then
	        echo "ERROR executing chmod"
		exit 1
	    fi
	    echo ""
	fi

	tgzs="$tgzs $t"
    done

    # Invoke efm.

    if test "${!remote}" != "" -a $move -eq 1
    then
        m="moveto"
	if test $clean -eq 0 -o "${!make_cd}" == "1"
	then
	    m="copyto"
	fi
        for t in $tgzs
	do
	    if test $efm_used -eq 0
	    then
		efm_used=1
		if test "$efm_trace" != ""
		then
		    set efm_old_trace="`efm trace`"
		    efm trace $efm_trace
		fi
	    fi
	    echo efm $m "${!remote}" $t
	    efm $m "${!remote}" $t
	    if test $? -ne 0
	    then
	        echo "ERROR executing efm $m"
		exit 1
	    fi
	    echo ""
	    efms="$efms $t"
	done
    fi

    # Make .raw.

    if test $raw -eq 1 -a "${!make_cd}" == "1"
    then
	rm -f $r
	echo mkisofs -RT -v -o $r $tgzs
	mkisofs -RT -v -o $r $tgzs 2>&1 \
	    | grep -v '^Writing:' \
	    | grep -v '^Done with:' \
	    | grep -v 'done, estinated finish'
	if test $? -ne 0
	then
	    echo "ERROR executing mkisofs"
	    exit 1
	fi
	echo ""
    fi

    # Burn.

    if test "${!make_cd}" == "1" -a $burn -eq 1
    then
	echo cdrecord -v $cd_options $r
	cdrecord -v $cd_options $r
	if test $? -ne 0
	then
	    echo "ERROR executing cdrecord"
	    exit 1
	fi
	echo eject /dev/cdrom
	eject /dev/cdrom
	echo ""
    fi

    # Check.

    if test "${!make_cd}" == "1" -a $check -eq 1
    then
	echo cmp /dev/cdrom $r
	cmp /dev/cdrom $r
	if test $? -ne 0
	then
	    echo "ERROR executing cmp"
	    exit 1
	fi
	echo eject /dev/cdrom
	eject /dev/cdrom
	echo ""
    fi

    # Clean.

    if test "${!make_cd}" == "1" -a $clean -eq 1
    then
	rm -f $r $tgzs
    fi

    # Handle CD labeling announcement and pause.
    #
    if test "${!make_cd}" == "1" -a $burn$check -ne 0
    then
        echo "CD $cd ejected; it contains:"
	for t in $tgzs
	do
	    echo "    $t"
	done
	echo ""

	if test "$next_name" != ""
	then
	    echo "Type ENTER to continue"
	    read -r
	fi
    fi

done

# List efms.

if test $efm_used -ne 0
then
    mv -f EFM-INDEX.listall EFM-INDEX.listall-
    efm listall > EFM-INDEX.listall
    case "$efm_old_trace" in
        *off)	efm trace off;;
	*on)	efm trace on;;
    esac
fi

if test "$efms" != ""
then
    efm list $efms
fi

exit 0
